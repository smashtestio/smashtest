// NOTE: This file was used to experiment with different types of testing styles (hence the inconsistency of style)

* init {
    chai.use(i('chai-as-promised'));

    g('setPageBody',
        async function(htmlStr) {
            await browser.executeScript(function(htmlStr) {
                document.body.innerHTML = htmlStr;
            }, htmlStr);
        }
    );

    g(`test page location`, `file:///${dir()}/generic-page.html`);
}

open chrome       #mac #windows $
open firefox      #mac #windows $
open safari       #mac $
open ie           #windows
open edge         #windows

    init
        navigate to {test page location}

            - BrowserInstance tests

                - Script injection tests

                    execScript() {
                        let body = await executeScript(function(a, b) {
                            document.body.innerHTML = a + b;
                            return document.body.innerHTML;
                        }, 'foo', 'bar');

                        expect(body).to.equal('foobar');
                    }

                    executeAsyncScript() {
                        let body = await executeAsyncScript(function(a, b, done) {
                            document.body.innerHTML = a + b;
                            done(document.body.innerHTML);
                        }, 'foo', 'bar');

                        expect(body).to.equal('foobar');
                    }

                - Elements tests

                    - $() tests

                        Given only some elements on a page are clickable

                            function $() is called

                                with a text EF
                                with a single-line untrimmed text EF
                                with an ElementFinder object

                                    and tryClickable is set to

                                        true

                                            When the call is made
                                                Then first matching element that is clickable is returned

                                        false

                                            When the call is made
                                                Then first matching element is returned

                                with a WebElement

                                    When the call is made
                                        Then the same WebElement is returned

                        Given no elements on a page are clickable

                            and function $() is called

                                with a text EF
                                with a single-line untrimmed text EF
                                with an ElementFinder object

                                    and tryClickable is set to

                                        true
                                        false

                                            When the call is made
                                                Then first matching element is returned

                                with a WebElement

                                    When the call is made
                                        Then the same WebElement is returned


                        * only some elements on a page are clickable {
                            await setPageBody(`
                                <div id="one" class="big">foobar</div>
                                <a id="two" class="big">foobar</a>
                                <button id="three" class="big">foobar</button>
                            `);
                        }

                        * no elements on a page are clickable {
                            await setPageBody(`
                                <div id="one" class="big">foobar</div>
                                <div id="two" class="big">foobar</div>
                                <span id="three" class="big">foobar</span>
                            `);
                        }

                        * function $() is called

                            * with a text EF {
                                g('element passed in',
                                    `.big`
                                );
                            }

                            * with a single-line untrimmed text EF {
                                g('element passed in',
                                    ` .big `
                                );
                            }

                            * with an ElementFinder object {
                                g('element passed in',
                                    new ElementFinder(`.big`)
                                );
                            }

                            * with a WebElement {
                                g('element passed in',
                                    await browser.driver.findElement(By.id('two'))
                                );
                            }

                                * When the call is made {
                                    g('result element',
                                        await $(g('element passed in'))
                                    );
                                }

                                    * Then the same WebElement is returned {
                                        expect(await g('result element').getAttribute('id')).to.equal('two');
                                    }

                        * tryClickable is set to

                            * true

                                * When the call is made {
                                    g('result element',
                                        await $(g('element passed in'), true)
                                    );
                                }

                            * false

                                * When the call is made {
                                    g('result element',
                                        await $(g('element passed in'), false)
                                    );
                                }

                        * Then first matching element that is clickable is returned {
                            expect(await g('result element').getAttribute('id')).to.equal('two');
                        }

                        * Then first matching element is returned {
                            expect(await g('result element').getAttribute('id')).to.equal('one');
                        }

                    - $$() tests

                        Given a page with multiple elements

                            and function $$() is called

                                with a text EF
                                with an ElementFinder object

                                    and the EF has a counter
                                        When the call is made
                                            Then all matching elements are returned

                                    and the EF is missing a counter
                                        When the call is made
                                            Then all matching elements are returned

                                with a WebElement
                                    When the call is made
                                        Then the same WebElement is returned

                        * Given a page with multiple elements {
                            await setPageBody(`
                                <div id="one" class="big">foobar</div>
                                <a id="two" class="big">foobar</a>
                                <button id="three" class="big">foobar</button>
                            `);
                        }

                            * function $$() is called

                                * with a text EF

                                    * the EF has a counter {
                                        g('element passed in',
                                            `3 x .big`
                                        );
                                    }

                                    * the EF is missing a counter {
                                        g('element passed in',
                                            `.big`
                                        );
                                    }

                                * with an ElementFinder object

                                    * the EF has a counter {
                                        g('element passed in',
                                            new ElementFinder(`3 x .big`)
                                        );
                                    }

                                    * the EF is missing a counter {
                                        g('element passed in',
                                            new ElementFinder(`.big`)
                                        );
                                    }

                                * with a WebElement {
                                    g('element passed in',
                                        await browser.driver.findElement(By.id('two'))
                                    );
                                }

                                    * When the call is made {
                                        g('result elements',
                                            await $$(g('element passed in'))
                                        );
                                    }

                                        * Then the same WebElement is returned {
                                            expect(g('result elements')).to.have.lengthOf(1);
                                            expect(await g('result elements')[0].getAttribute('id')).to.equal('two');
                                        }

                                * When the call is made {
                                    g('result elements',
                                        await $$(g('element passed in'))
                                    );
                                }

                                    * Then all matching elements are returned {
                                        expect(g('result elements')).to.have.lengthOf(3);
                                        expect(await g('result elements')[0].getAttribute('id')).to.equal('one');
                                        expect(await g('result elements')[1].getAttribute('id')).to.equal('two');
                                        expect(await g('result elements')[2].getAttribute('id')).to.equal('three');
                                    }

                    - 'not$()' tests

                        Given a page with multiple elements {
                            await setPageBody(`
                                <div id="one" class="big">foobar</div>
                            `);
                        }

                            - and not$() is called

                                with a text EF that doesn't match anything {
                                    g('element', `.none`);
                                }
                                with an ElementFinder object that doesn't match anything {
                                    g('element', new ElementFinder(`.none`));
                                }

                                    no error is thrown {
                                        await not$(element, undefined, 1000);
                                    }

                                with an EF that continues to match after the timeout {
                                    g('element', `.big`);
                                }
                                with a valid WebElement that never disappears {
                                    g('element', await browser.driver.findElement(By.id('one')));
                                }

                                    an error is thrown {
                                        await expect(not$(element, undefined, 1000)).to.be.rejectedWith(`Element still found after timeout (1 s)`);
                                    }

                    - props() tests

                        - Setting one prop

                            - Given a prop is

                                - already defined

                                    define prop {
                                        props({
                                            fuzzy: `.original-fuzzy`
                                        });
                                    }

                                        - When that prop is set with props()

                                            - to an EF

                                                - with isAdd set to true

                                                    call {
                                                        props({
                                                            fuzzy: `.fuzzy`
                                                        }, true);
                                                    }

                                                        - Then the old definition gets added to

                                                            verify {
                                                                expect(browser.definedProps.fuzzy).to.have.lengthOf(2);
                                                                expect(browser.definedProps.fuzzy[0].props[0].input).to.equal('.original-fuzzy');
                                                                expect(browser.definedProps.fuzzy[1].props[0].input).to.equal('.fuzzy');
                                                            }

                                                - with isAdd set to false

                                                    call {
                                                        props({
                                                            fuzzy: `.fuzzy`
                                                        }, false);
                                                    }

                                                        - Then the old definition gets overridden

                                                            verify {
                                                                expect(browser.definedProps.fuzzy).to.have.lengthOf(1);
                                                                expect(browser.definedProps.fuzzy[0].props[0].input).to.equal('.fuzzy');
                                                            }

                                            - to a function

                                                - with isAdd set to true

                                                    call {
                                                        props({
                                                            fuzzy: (elems, input) => {
                                                                return elems.filter(elem => elem.classList.contains('fuzzy'))
                                                            }
                                                        }, true);
                                                    }

                                                        - Then the old definition gets added to

                                                            verify {
                                                                expect(browser.definedProps.fuzzy).to.have.lengthOf(2);
                                                                expect(browser.definedProps.fuzzy[0].props[0].input).to.equal('.original-fuzzy');
                                                                expect(typeof browser.definedProps.fuzzy[1]).to.equal('function');
                                                            }

                                                - with isAdd set to false

                                                    call {
                                                        props({
                                                            fuzzy: (elems, input) => {
                                                                return elems.filter(elem => elem.classList.contains('fuzzy'))
                                                            }
                                                        }, false);
                                                    }

                                                        - Then the old definition gets overridden

                                                            verify {
                                                                expect(browser.definedProps.fuzzy).to.have.lengthOf(1);
                                                                expect(typeof browser.definedProps.fuzzy[0]).to.equal('function');
                                                            }

                                - not yet defined

                                    - When that prop is set with props()
                                        [
                                            - with isAdd set to true

                                                call {
                                                    props({
                                                        fuzzy: `.fuzzy`
                                                    }, true);
                                                }

                                            - with isAdd set to false

                                                call {
                                                    props({
                                                        fuzzy: `.fuzzy`
                                                    }, false);
                                                }
                                        ]
                                            - Then the definition gets set

                                                verify {
                                                    expect(browser.definedProps.fuzzy).to.have.lengthOf(1);
                                                    expect(browser.definedProps.fuzzy[0].props[0].input).to.equal('.fuzzy');
                                                }

                        - Setting multiple props

                            - When multiple props are set with props()
                                and some of those props have already been set {
                                    props({
                                        one: `.one`,
                                        two: `.two`,
                                        three: `.three`
                                    });
                                }

                                    - and isAdd is set to
                                        - true
                                            Then the existing definitions get added to {
                                                props({
                                                    one: `.first`,
                                                    three: (elems, input) => { return elems; }
                                                }, true);

                                                Comparer.expect(browser.definedProps).to.match({
                                                    one: [
                                                        { props: [ '$subset', {input: `.one`} ] },
                                                        { props: [ '$subset', {input: `.first`} ] }
                                                    ],
                                                    two: [
                                                        { props: [ '$subset', {input: `.two`} ] }
                                                    ],
                                                    three: [
                                                        { props: [ '$subset', {input: `.three`} ] },
                                                        { $typeof: 'function' }
                                                    ]
                                                });
                                            }

                                        - false
                                            Then the existing definitions get overriden {
                                                props({
                                                    one: `.first`,
                                                    three: (elems, input) => { return elems; }
                                                }, false);

                                                Comparer.expect(browser.definedProps).to.match({
                                                    one: [
                                                        { props: [ '$subset', {input: `.first`} ] }
                                                    ],
                                                    two: [
                                                        { props: [ '$subset', {input: `.two`} ] }
                                                    ],
                                                    three: [
                                                        { $typeof: 'function' }
                                                    ]
                                                });
                                            }

                    - propsAdd() tests
                        Setting a prop with an existing definition {
                            props({
                                fuzzy: `.original-fuzzy`
                            });

                            propsAdd({
                                fuzzy: `.fuzzy`
                            });
                        }
                            Verify that the old definition gets added to {
                                Comparer.expect(browser.definedProps).to.match({
                                    fuzzy: [
                                        { props: [ '$subset', {input: `.original-fuzzy`} ] },
                                        { props: [ '$subset', {input: `.fuzzy`} ] }
                                    ]
                                });
                            }

                    - propsClear() tests
                        Clears out multiple props {
                            props({
                                one: `.one`,
                                two: `.two`,
                                three: `.three`
                            });

                            propsClear(['one', 'two']);

                            Comparer.expect(browser.definedProps).to.match({
                                three: [
                                    { props: [ '$subset', {input: `.three`} ] }
                                ]
                            });
                        }
                        Silently handles props that don't exist {
                            props({
                                one: `.one`,
                                two: `.two`,
                                three: `.three`
                            });

                            propsClear(['one', 'two', 'foobar']);

                            Comparer.expect(browser.definedProps).to.match({
                                three: [
                                    { props: [ '$subset', {input: `.three`} ] }
                                ]
                            });
                        }

                    - str() tests
                        Escapes quotes in a string {
                            expect(`'${str(`"meow"`)}'`).to.equal(`'\\"meow\\"'`);
                        }

                - Mocks tests

                    - mockTime() tests

                        When the mock date is set {
                            let date = g('date', new Date("1/2/2011 3:45 pm"));
                            await browser.mockTime(date);
                        }
                            Then that change is visible from 'new Date()' {
                                await executeScript(function() {
                                    document.body.innerHTML = `<div id="date"></div>`;
                                    let s = document.createElement("script");
                                    s.type = "text/javascript";
                                    s.innerHTML = `document.getElementById('date').innerHTML = (new Date()).toString();`
                                    document.body.append(s);
                                });

                                await $(`#date, '${str("Sun Jan 02 2011 15:45")}'`);
                            }

                    - mockHttp() tests

                        Navigate to 'example.com'

                            - Mocked method is a GET

                                - Mocked url is a string

                                    - Mocked response is a string

                                        Set up mock {
                                            await browser.mockHttp('GET', '/endpoint', 'foobar');
                                        }

                                            - When an http request is made from the browser

                                                - to a mocked endpoint

                                                    - and the request is an absolute url

                                                        Then the mocked response comes back {
                                                            let response = await browser.executeAsyncScript(function(done) {
                                                                var oReq = new XMLHttpRequest();
                                                                oReq.addEventListener('load', done);
                                                                oReq.open('GET', 'http://example.com/endpoint');
                                                                oReq.send();
                                                            });

                                                            Comparer.expect(response).to.match({
                                                                target: {
                                                                    status: 200,
                                                                    responseText: 'foobar'
                                                                }
                                                            });
                                                        }

                                                    - and the request is a relative url

                                                        Then the mocked response comes back {
                                                            let response = await browser.executeAsyncScript(function(done) {
                                                                var oReq = new XMLHttpRequest();
                                                                oReq.addEventListener('load', done);
                                                                oReq.open('GET', '/endpoint');
                                                                oReq.send();
                                                            });

                                                            Comparer.expect(response).to.match({
                                                                target: {
                                                                    status: 200,
                                                                    responseText: 'foobar'
                                                                }
                                                            });
                                                        }

                                                - to a non-mocked endpoint

                                                    Then a 404 error comes back {
                                                        let response = await browser.executeAsyncScript(function(done) {
                                                            var oReq = new XMLHttpRequest();
                                                            oReq.addEventListener('load', done);
                                                            oReq.open('GET', '/badendpoint');
                                                            oReq.send();
                                                        });

                                                        Comparer.expect(response).to.match({
                                                            target: {
                                                                status: 404
                                                            }
                                                        });
                                                    }

                                    - Mocked response is a js object

                                        Set up mock {
                                            await browser.mockHttp('GET', '/endpoint', {foo:'bar'});
                                        }

                                            - When an http request is made from the browser

                                                - to a mocked endpoint

                                                    - and the request is an absolute url

                                                        Then the mocked response comes back {
                                                            let response = await browser.executeAsyncScript(function(done) {
                                                                var oReq = new XMLHttpRequest();
                                                                oReq.addEventListener('load', done);
                                                                oReq.open('GET', 'http://example.com/endpoint');
                                                                oReq.send();
                                                            });

                                                            Comparer.expect(response).to.match({
                                                                target: {
                                                                    status: 200,
                                                                    responseText: '{"foo":"bar"}'
                                                                }
                                                            });
                                                        }

                                                    - and the request is a relative url

                                                        Then the mocked response comes back {
                                                            let response = await browser.executeAsyncScript(function(done) {
                                                                var oReq = new XMLHttpRequest();
                                                                oReq.addEventListener('load', done);
                                                                oReq.open('GET', '/endpoint');
                                                                oReq.send();
                                                            });

                                                            Comparer.expect(response).to.match({
                                                                target: {
                                                                    status: 200,
                                                                    responseText: '{"foo":"bar"}'
                                                                }
                                                            });
                                                        }

                                                - to a non-mocked endpoint

                                                    Then a 404 error comes back {
                                                        let response = await browser.executeAsyncScript(function(done) {
                                                            var oReq = new XMLHttpRequest();
                                                            oReq.addEventListener('load', done);
                                                            oReq.open('GET', '/badendpoint');
                                                            oReq.send();
                                                        });

                                                        Comparer.expect(response).to.match({
                                                            target: {
                                                                status: 404
                                                            }
                                                        });
                                                    }

                                    - Mocked response is an array

                                        Set up mock {
                                            await browser.mockHttp('GET', '/some/endpoint', [201, {'Content-Type': 'application/json'}, 'foobar']);
                                        }

                                            - When an http request is made from the browser

                                                - to a mocked endpoint

                                                    - and the request is an absolute url

                                                        Then the mocked response comes back {
                                                            let response = await browser.executeAsyncScript(function(done) {
                                                                var oReq = new XMLHttpRequest();
                                                                oReq.addEventListener('load', done);
                                                                oReq.open('GET', 'http://example.com/some/endpoint');
                                                                oReq.send();
                                                            });

                                                            Comparer.expect(response).to.match({
                                                                target: {
                                                                    status: 201,
                                                                    responseText: 'foobar',
                                                                    responseHeaders: {
                                                                        'Content-Type': 'application/json'
                                                                    }
                                                                }
                                                            });
                                                        }

                                                    - and the request is a relative url

                                                        Then the mocked response comes back {
                                                            let response = await browser.executeAsyncScript(function(done) {
                                                                var oReq = new XMLHttpRequest();
                                                                oReq.addEventListener('load', done);
                                                                oReq.open('GET', '/some/endpoint');
                                                                oReq.send();
                                                            });

                                                            Comparer.expect(response).to.match({
                                                                target: {
                                                                    status: 201,
                                                                    responseText: 'foobar',
                                                                    responseHeaders: {
                                                                        'Content-Type': 'application/json'
                                                                    }
                                                                }
                                                            });
                                                        }

                                                - to a non-mocked endpoint

                                                    Then a 404 error comes back {
                                                        let response = await browser.executeAsyncScript(function(done) {
                                                            var oReq = new XMLHttpRequest();
                                                            oReq.addEventListener('load', done);
                                                            oReq.open('GET', '/some/badendpoint');
                                                            oReq.send();
                                                        });

                                                        Comparer.expect(response).to.match({
                                                            target: {
                                                                status: 404
                                                            }
                                                        });
                                                    }

                                    - Mocked response is a function

                                        Set up mock {
                                            await browser.mockHttp('GET', '/some/endpoint', function(xhr) {
                                                xhr.respond(201, {'Content-Type': 'application/json'}, 'foobar');
                                            });
                                        }

                                            - When an http request is made from the browser

                                                - to a mocked endpoint

                                                    - and the request is an absolute url

                                                        Then the mocked response comes back {
                                                            let response = await browser.executeAsyncScript(function(done) {
                                                                var oReq = new XMLHttpRequest();
                                                                oReq.addEventListener('load', done);
                                                                oReq.open('GET', 'http://example.com/some/endpoint');
                                                                oReq.send();
                                                            });

                                                            Comparer.expect(response).to.match({
                                                                target: {
                                                                    status: 201,
                                                                    responseText: 'foobar',
                                                                    responseHeaders: {
                                                                        'Content-Type': 'application/json'
                                                                    }
                                                                }
                                                            });
                                                        }

                                                    - and the request is a relative url

                                                        Then the mocked response comes back {
                                                            let response = await browser.executeAsyncScript(function(done) {
                                                                var oReq = new XMLHttpRequest();
                                                                oReq.addEventListener('load', done);
                                                                oReq.open('GET', '/some/endpoint');
                                                                oReq.send();
                                                            });

                                                            Comparer.expect(response).to.match({
                                                                target: {
                                                                    status: 201,
                                                                    responseText: 'foobar',
                                                                    responseHeaders: {
                                                                        'Content-Type': 'application/json'
                                                                    }
                                                                }
                                                            });
                                                        }

                                                - to a non-mocked endpoint

                                                    Then a 404 error comes back {
                                                        let response = await browser.executeAsyncScript(function(done) {
                                                            var oReq = new XMLHttpRequest();
                                                            oReq.addEventListener('load', done);
                                                            oReq.open('GET', '/some/badendpoint');
                                                            oReq.send();
                                                        });

                                                        Comparer.expect(response).to.match({
                                                            target: {
                                                                status: 404
                                                            }
                                                        });
                                                    }

                                - Mocked url is a regex

                                    Set up mock {
                                        await browser.mockHttp('GET', /\/end.*/, 'foobar');
                                    }

                                        - When an http request is made from the browser

                                            - to a mocked endpoint

                                                - and the request is an absolute url

                                                    Then the mocked response comes back {
                                                        let response = await browser.executeAsyncScript(function(done) {
                                                            var oReq = new XMLHttpRequest();
                                                            oReq.addEventListener('load', done);
                                                            oReq.open('GET', 'http://example.com/endpoint');
                                                            oReq.send();
                                                        });

                                                        Comparer.expect(response).to.match({
                                                            target: {
                                                                status: 200,
                                                                responseText: 'foobar'
                                                            }
                                                        });
                                                    }

                                                - and the request is a relative url

                                                    Then the mocked response comes back {
                                                        let response = await browser.executeAsyncScript(function(done) {
                                                            var oReq = new XMLHttpRequest();
                                                            oReq.addEventListener('load', done);
                                                            oReq.open('GET', '/endpoint');
                                                            oReq.send();
                                                        });

                                                        Comparer.expect(response).to.match({
                                                            target: {
                                                                status: 200,
                                                                responseText: 'foobar'
                                                            }
                                                        });
                                                    }

                                            - to a non-mocked endpoint

                                                Then a 404 error comes back {
                                                    let response = await browser.executeAsyncScript(function(done) {
                                                        var oReq = new XMLHttpRequest();
                                                        oReq.addEventListener('load', done);
                                                        oReq.open('GET', '/badendpoint');
                                                        oReq.send();
                                                    });

                                                    Comparer.expect(response).to.match({
                                                        target: {
                                                            status: 404
                                                        }
                                                    });
                                                }

                            - Mocked method is a POST

                                Set up mock {
                                    await browser.mockHttp('POST', '/endpoint', 'foobar');
                                }

                                    - When an http request is made from the browser

                                        - to a mocked endpoint

                                            - and the request is an absolute url

                                                Then the mocked response comes back {
                                                    let response = await browser.executeAsyncScript(function(done) {
                                                        var oReq = new XMLHttpRequest();
                                                        oReq.addEventListener('load', done);
                                                        oReq.open('POST', 'http://example.com/endpoint');
                                                        oReq.send();
                                                    });

                                                    Comparer.expect(response).to.match({
                                                        target: {
                                                            status: 200,
                                                            responseText: 'foobar'
                                                        }
                                                    });
                                                }

                                            - and the request is a relative url

                                                Then the mocked response comes back {
                                                    let response = await browser.executeAsyncScript(function(done) {
                                                        var oReq = new XMLHttpRequest();
                                                        oReq.addEventListener('load', done);
                                                        oReq.open('POST', '/endpoint');
                                                        oReq.send();
                                                    });

                                                    Comparer.expect(response).to.match({
                                                        target: {
                                                            status: 200,
                                                            responseText: 'foobar'
                                                        }
                                                    });
                                                }

                                        - to a non-mocked endpoint

                                            - where the path isn't mocked

                                                Then a 404 error comes back {
                                                    let response = await browser.executeAsyncScript(function(done) {
                                                        var oReq = new XMLHttpRequest();
                                                        oReq.addEventListener('load', done);
                                                        oReq.open('POST', '/badendpoint');
                                                        oReq.send();
                                                    });

                                                    Comparer.expect(response).to.match({
                                                        target: {
                                                            status: 404
                                                        }
                                                    });
                                                }

                                            - where the method isn't mocked

                                                Then a 404 error comes back {
                                                    let response = await browser.executeAsyncScript(function(done) {
                                                        var oReq = new XMLHttpRequest();
                                                        oReq.addEventListener('load', done);
                                                        oReq.open('GET', '/endpoint');
                                                        oReq.send();
                                                    });

                                                    Comparer.expect(response).to.match({
                                                        target: {
                                                            status: 404
                                                        }
                                                    });
                                                }

                    - mockHttpConfigure() tests

                        - mockHttp() was
                            already called {
                                await browser.mockHttp('GET', '/endpoint', 'foobar');
                            }
                                Verify default config {
                                    let autoRespond = await browser.executeScript(function() {
                                        return window.smashtestSinonFakeServer.autoRespond;
                                    });
                                    expect(autoRespond).to.be.null;
                                }
                                    Calling mockHttpConfigure() {
                                        await browser.mockHttpConfigure({autoRespond: false});
                                    }
                                        Updates the config {
                                            let autoRespond = await browser.executeScript(function() {
                                                return window.smashtestSinonFakeServer.autoRespond;
                                            });
                                            expect(autoRespond).to.be.false;
                                        }
                            not called yet {
                            }
                                Calling mockHttpConfigure() {
                                    await browser.mockHttpConfigure({autoRespond: false});
                                }
                                    - Does nothing

                    - mockTimeStop() tests
                        - mockTime() was
                            already called {
                                let date = g('date', new Date("1/2/2011 3:45 pm"));
                                await browser.mockTime(date);
                            }
                                Calling mockTimeStop() {
                                    await browser.mockTimeStop();
                                }
                                    Restores the current time {
                                        await executeScript(function() {
                                            document.body.innerHTML = `<div id="date"></div>`;
                                            let s = document.createElement("script");
                                            s.type = "text/javascript";
                                            s.innerHTML = `document.getElementById('date').innerHTML = (new Date()).toString();`
                                            document.body.append(s);
                                        });

                                        await not$(`#date, '${str(date.toString())}'`);
                                    }
                            not called yet {
                            }
                                Calling mockTimeStop() {
                                    await browser.mockTimeStop();
                                }
                                    - Does nothing

                    - mockHttpStop() tests

                        Navigate to 'example.com'

                            - mockHttp() was
                                already called {
                                    await browser.mockHttp('GET', '/', 'foobar');
                                }
                                    Calling mockHttpStop() {
                                        await browser.mockHttpStop();
                                    }
                                        and making an http request {
                                            return await browser.executeAsyncScript(function(done) {
                                                var oReq = new XMLHttpRequest();
                                                oReq.addEventListener('load', function(result) {
                                                    done(result != 'foobar');
                                                });
                                                oReq.open('GET', '/');
                                                oReq.send();
                                            });
                                        }
                                            Gets a response from the original non-mocked http server {
                                                expect(prev).to.be.true;
                                            }

                                not called yet {
                                }
                                    Calling mockHttpStop() {
                                        await browser.mockHttpStop();
                                    }
                                        - Does nothing

                    - mockStop() tests
                        ..
                        Mock time {
                            let date = g('date', new Date("1/2/2011 3:45 pm"));
                            await browser.mockTime(date);
                        }
                        Mock http {
                            await browser.mockHttp('GET', '/', 'foobar');
                        }
                        Navigate to 'example.com'

                            Calling mockStop() .. {
                                await browser.mockStop();
                            }

                                and getting the date {
                                    await executeScript(function() {
                                        document.body.innerHTML = `<div id="date"></div>`;
                                        let s = document.createElement("script");
                                        s.type = "text/javascript";
                                        s.innerHTML = `document.getElementById('date').innerHTML = (new Date()).toString();`
                                        document.body.append(s);
                                    });
                                }

                                    gets the original current date {
                                        await not$(`#date, '${str(date.toString())}'`);
                                    }

                                and making an http request {
                                    return await browser.executeAsyncScript(function(done) {
                                        var oReq = new XMLHttpRequest();
                                        oReq.addEventListener('load', function(result) {
                                            done(result != 'foobar');
                                        });
                                        oReq.open('GET', '/');
                                        oReq.send();
                                    });
                                }
                                    Gets a response from the original non-mocked http server {
                                        expect(prev).to.be.true;
                                    }

                    - injectSinon() tests

                        Sinon already exists in browser {
                            await browser.injectSinon();
                        }
                        Sinon does not already exist in browser {
                        }

                            When injectSinon() is called {
                                await browser.injectSinon();
                            }

                                Then the global sinon object is accessible within browser {
                                    let exists = await browser.executeScript(function() {
                                        return typeof sinon != 'undefined';
                                    });
                                    expect(exists).to.be.true;
                                }

                - Screenshots tests

                    make html page very long, with a button at the very bottom (below the fold) {
                        let body = '';
                        for(let i = 0; i < 500; i++) body += '<div>foobar</div>';
                        body += '<button>Click me</button>';
                        await setPageBody(body);
                    }
                        Click [button]
                            - Verify that the button is visible in the before screenshot, with crosshairs $s #manual
